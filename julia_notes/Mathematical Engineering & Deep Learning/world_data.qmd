---
author: Ernest Orlowski
format: html
engine: julia
# jupyter: julia-1.11
execute:
  cache: true
  daemon: true
  echo: fenced
---
# World Data from Mathematical Engineering & Deep Learning (2024, CRC Press)

From a Google search on Jan 17, 2024 with a search string "amount of data in the world in YYYY". Only collected results for which Google displayed a summarizing string. The first two years, 2006 & 2007, were in etabytes, and later in zetabytes (ZB). Everything was converted to ZB.
Some years presented the stored data and others the created data.

```{julia}
using DataFrames, GLM, Plots, Missings
```
```{julia}
data = DataFrame(
    year = [2006, 2007, 2010, 2012, 2018, 2021, 2022],
    created_data = [0.16, missing, 1.2, missing, 33, 79, 97],
    stored_data = [missing, 0.29, missing, 2.8, missing, missing, missing]
)
data.year = data.year .- 2000;  # change year to be 2000 -- needed for fitting
data
```

Fitting the model, $log(y) = β_0 + β_1x_1$ or
$y = e^{\beta_0}e^{\beta_1x} = Ke^{αx}$

```{julia}
model_created = fit(LinearModel, @formula(log(created_data) ~ year), data)
```
<!-- Should return: `:(log(created_data)) ~ 1 + year -->
```{julia}
β0, β1 = coef(model_created);
K, α = exp(β0), β1
```

Stored data at time $t$:
$\int_{-\infty}^{t} K e^{αu}du = \frac{K}{α}e^{αt}$

Its predicted at time $t$ divided by $α$. So its quite easy to see these stored observations multiplied by the initial alpha estimate as other observations.
This is like a two stage analysis.
```{julia}
data[2, :created_data] = round(data[2, :stored_data] / α, digits=2)
data[4, :created_data] = round(data[4, :stored_data] / α, digits=2)
data
```

```{julia}
model_created = fit(LinearModel, @formula(log(created_data) ~ year), data)
```

```{julia}
β0, β1 = coef(model_created);
K, α = exp(β0), β1
```

Getting a bit more: see the ratio of created data to stored data. The stored data web search results in 2007 & 2012; below are the predictions for those years.

```{julia}
pred_created(year) = K * exp(α * (year - 2000))
pred_stored(year) = (1 / 3) * pred_created(year) / α  # assume a third of the data is being kept
```
```{julia}
pred_created(2007), pred_created(2012)
# (0.48631333906766927, 3.112614457694469)
```

```{julia}
pred_created(2007)/0.29, pred_created(2012)/2.8
# (1.6769425485092044, 1.1116480206051675)
```

```{julia}
plot(2005:2025, pred_created.(2005:2025), lw = 1, label = "Fit of created", c = :black)
scatter!(dropmissing(data, :created_data).year .+ 2000, dropmissing(data, :created_data).created_data, label = "Yearly estimate created", c = :black, xticks = 2000:5:2025, xlim = (2005, 2026), ylim = (0, 150))
```

```{julia}
years = 2020:2030
yota_world = pred_stored.(years)/1024
bar(years, yota_world, xticks = years, label = :none, xlabel = "Year", ylabel = "Data volume in yotabytes", ylim = (0, 3.1))
```

```{julia}
savefig("./years_data_zb.pdf")
```

```{julia}
using LaTeXStrings, Distributions

sq_err(x) = x^2
abs_err(x) = abs(x)
hub_err(x) = abs(x) < 1 ? x^2/2 : abs(x) - 1/2
```

```{julia}
x_grid = -2:0.005:2

p1 = plot(x_grid, sq_err.(x_grid), label = "Squared Loss", legend = :topleft, xlabel = L"\hat{y}^{(i)} - y^{(i)}", ylabel = "Loss", lw = 2, legendfont = font(12))
plot!(x_grid, abs_err.(x_grid), label = "Absolute loss", lw = 2)
plot!(x_grid, hub_err.(x_grid), label = "Huber loss (δ = 1)", lw = 2)
```
